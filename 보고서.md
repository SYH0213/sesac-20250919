# CRAG 미니 프로젝트 고도화 보고서

## 1. RAG 프로젝트 고도화: CRAG 및 동적 UI 구현

`homework.md`의 요구사항에 따라, 기존 RAG(Retrieval-Augmented Generation) 프로젝트의 아키텍처와 사용자 경험을 대폭 개선했습니다. 핵심 목표는 LangGraph를 사용해 파이프라인을 재설계하고, CRAG(Corrective RAG) 개념을 도입하여 보다 지능적인 질의응답 시스템을 구축하는 것이었습니다.

### 1.1. 주요 개선 사항

#### 1.1.1. 동적 문서 처리 UI (Gradio)

기존의 하드코딩된 파일 경로 방식에서 벗어나, 사용자가 웹 UI에서 직접 PDF 문서를 선택하거나 새로 업로드할 수 있도록 동적인 인터페이스를 구현했습니다.

-   **기능**: PDF 선택 드롭다운, 파일 업로드 버튼
-   **효과**: 사용 편의성 증대 및 여러 문서를 독립적으로 관리할 수 있는 확장성 확보

![UI 초기 화면](./images/1.png)

#### 1.1.2. 지능형 RAG 파이프라인 (LangGraph & CRAG)

LangGraph를 도입하여, 사용자 입력을 '단순 대화'와 '정보성 질문'으로 먼저 분류하는 지능형 라우팅 파이프라인을 구축했습니다.

-   **지능형 라우팅**: 대화형 입력은 불필요한 검색 과정을 건너뛰고 즉시 답변을 생성하여 응답 속도와 효율성을 높였습니다.
-   **품질 평가 (Corrective)**: 검색된 문서가 질문과 관련 없는 경우, LLM이 스스로 이를 판단하여 답변 생성에서 제외함으로써 환각(Hallucination) 현상을 억제합니다.
-   **정보 보강 (Augmented)**: 관련 문서가 없다고 판단되면, 질문을 웹 검색에 적합하게 재작성한 뒤, 웹 검색을 통해 외부 정보를 탐색하여 답변을 생성합니다.

![웹 검색을 통한 정보 보강](./images/8.png)

#### 1.1.3. 핵심 로직 개선: PDF 파서 교체

`LlamaParse`에 대한 의존성을 제거하고, Gemini 2.5 Pro API를 직접 호출하여 PDF의 텍스트와 테이블을 추출하는 `gemini_parser.py` 모듈을 자체 구현했습니다. 이를 통해 외부 서비스의 제약에서 벗어나 안정적인 데이터 처리 기반을 마련했습니다.

![Gemini Parser 코드](./images/2.png)
![Gemini Parser 실행](./images/3.png)

### 1.2. 전체 파이프라인 아키텍처

아래는 LangGraph로 구현된 전체 워크플로우의 흐름과 시각화된 그래프입니다.

```
[START]
   │
   ▼
[classify_input]  ── 의도분류 → { conversational | question }
   │
   ├─ if conversational ───────────────► [generate_conversational_response] ─► (END)
   │
   └─ if question
        │
        ▼
    [retrieve] ──(history-aware)──► 문서 검색
        │
        ▼
 [grade_documents] ── 문서 관련성 평가
        │
        ├─ 관련 문서 있음(Yes) ─► [generate] ────────────────────────────────► (END)
        │
        └─ 관련 문서 없음(No)
                 │
                 ▼
          [notify_user] ── "문서에서 답변 실패, 웹검색 시도"
                 │
                 ▼
        [transform_query] ── 검색 친화적 쿼리로 재작성
                 │
                 ▼
         [web_search_node] ── (Tavily) 웹결과를 문맥으로 추가
                 │
                 ▼
               [generate] ───────────────────────────────────────────────────► (END)
```

![LangGraph 파이프라인 시각화](./images/9.png)

---

## 2. 학습 내용 정리: 심층 문제 해결 과정

이번 프로젝트 고도화 과정에서 겪었던 가장 큰 어려움은 **예상치 못한 API 오류를 해결하는 과정**이었습니다. 이 경험은 단순한 코딩을 넘어, 문제의 근본 원인을 추적하는 시스템적인 디버깅 능력을 기르는 데 큰 도움이 되었습니다.

### 2.1. 상황: 잘 작동하던 기능이 갑자기 특정 PDF에서 오류를 일으키다

동일한 코드와 파일임에도 불구하고, 어느 순간부터 특정 PDF 파일을 처리할 때 `google.genai.errors.ClientError: 400 INVALID_ARGUMENT` 오류가 발생하기 시작했습니다.

![오류 발생 화면](./images/4.png)

### 2.2. 잘못된 가설과 막다른 길

문제 해결을 위해 API 할당량 소진, API 인증 방식의 문제 등 여러 가설을 세우고 검증했지만, 모두 근본적인 해결책이 아니었습니다.

![API 키 확인](./images/5.png)

### 2.3. 돌파구: 진짜 원인의 발견

코드와 API 설정의 미로에 갇혀있을 때, **진짜 원인은 바로 운영체제(OS) 수준의 "파일 연결(기본 프로그램)" 설정**이라는 결정적인 단서를 발견했습니다.

-   **문제**: 오류가 발생하던 PDF 파일의 기본 프로그램이 윈도우에서 **'한컴 PDF'**로 설정되어 있었습니다.
-   **메커니즘**: `google-generativeai` 라이브러리는 파일을 업로드할 때, OS의 파일 연결 설정을 참고하여 파일의 `mime_type`을 추론합니다. '한컴 PDF'와의 연결 때문에, 라이브러리는 이 파일의 `mime_type`을 표준적인 `application/pdf`가 아닌, **비표준적인 `mime_type`으로 잘못 인식**했던 것입니다.
-   **결과**: 잘못된 `mime_type` 정보와 함께 파일이 구글 서버로 업로드되었고, 모델이 이 파일을 처리하려 할 때, "처리할 수 없는 종류의 파일"이라 판단하여 `400 INVALID_ARGUMENT` 오류를 반환했던 것입니다.

![파일 기본 프로그램 설정 변경](./images/6.png)

사용자가 직접 파일의 기본 프로그램을 표준 PDF 리더(Adobe Acrobat 등)로 변경하자, `mime_type`이 `application/pdf`로 올바르게 인식되었고, 모든 문제가 해결되었습니다.

![문제 해결 후 정상 작동](./images/7.png)

### 2.4. 교훈: 시스템 전체를 보는 눈

이번 경험을 통해 **API 관련 오류의 근본 원인은 코드나 API 키 자체를 넘어, 코드가 실행되는 운영체제 환경이나 데이터 자체의 숨겨진 속성 등 예상치 못한 곳에 있을 수 있다**는 중요한 교훈을 얻었습니다. 오류 메시지에만 매몰되지 않고, 문제가 발생하는 상황과 그렇지 않은 상황의 **환경적 차이**를 집요하게 파고들어 근본 원인을 찾아낸 좋은 경험이었습니다.

---

## 3. 결론

본 프로젝트를 통해 단순 RAG를 넘어 CRAG 아키텍처를 성공적으로 구현하였으며, 사용자 중심의 동적 UI를 통해 시스템의 사용성과 확장성을 크게 향상시켰습니다. 특히 예측 불가능한 오류를 시스템 전체의 관점에서 분석하고 해결하는 과정을 통해, 기술적 문제 해결 능력을 한 단계 발전시킬 수 있었습니다.

---

## 4. 완성 코드 제출

위의 모든 기능과 학습 내용이 반영된 최종 `CRAG.py` 및 `gemini_parser.py` 코드를 함께 제출합니다.
